<<<<<<< HEAD
CCS PCH C Compiler, Version 5.070, 56587               24-sep-17 12:09
=======
CCS PCH C Compiler, Version 5.070, 56587               24-sep-17 14:20
>>>>>>> d2785c6c4ccee8bfc8f6528921224d0bb4f350dd

               Filename:   C:\Users\Jaime\Documents\GitHub\SIM800L-18F\SERIE\main.lst

               ROM used:   1578 bytes (5%)
                           Largest free fragment is 31186
               RAM used:   54 (3%) at main() level
                           77 (4%) worst case
               Stack used: 12 locations (6 in main + 6 for interrupts)
               Stack size: 31

*
0000:  GOTO   04D4
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0208
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18f2550.h>	//Tipo de procesador 
.................... //////////// Standard Header file for the PIC18F2550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2550 
*
01E2:  MOVF   FEF,F
01E4:  BZ    0204
01E6:  MOVFF  FEA,42
01EA:  MOVFF  FE9,41
01EE:  MOVFF  FEF,43
01F2:  RCALL  0192
01F4:  MOVFF  42,FEA
01F8:  MOVFF  41,FE9
01FC:  INCF   FE9,F
01FE:  BTFSC  FD8.2
0200:  INCF   FEA,F
0202:  BRA    01E2
0204:  GOTO   0232 (RETURN)
*
0238:  DATA 41,54
023A:  DATA 0D,00
023C:  DATA 54,4F
023E:  DATA 44,4F
0240:  DATA 20,42
0242:  DATA 49,45
0244:  DATA 4E,00
0246:  DATA 41,54
0248:  DATA 2B,43
024A:  DATA 4D,47
024C:  DATA 53,3D
024E:  DATA 3F,00
0250:  DATA 41,54
0252:  DATA 2B,43
0254:  DATA 4D,47
0256:  DATA 53,3D
0258:  DATA 3F,0D
025A:  DATA 00,00
025C:  DATA 41,54
025E:  DATA 2B,43
0260:  DATA 4D,47
0262:  DATA 46,3D
0264:  DATA 31,00
0266:  DATA 41,54
0268:  DATA 2B,43
026A:  DATA 4D,47
026C:  DATA 46,3D
026E:  DATA 31,0D
0270:  DATA 00,00
0272:  DATA 41,54
0274:  DATA 2B,43
0276:  DATA 4D,47
0278:  DATA 53,3D
027A:  DATA 22,2B
027C:  DATA 35,39
027E:  DATA 33,39
0280:  DATA 35,39
0282:  DATA 39,38
0284:  DATA 34,31
0286:  DATA 31,30
0288:  DATA 22,00
028A:  DATA 41,54
028C:  DATA 2B,43
028E:  DATA 4D,47
0290:  DATA 53,3D
0292:  DATA 22,2B
0294:  DATA 35,39
0296:  DATA 33,39
0298:  DATA 35,39
029A:  DATA 39,38
029C:  DATA 34,31
029E:  DATA 31,30
02A0:  DATA 22,0D
02A2:  DATA 00,00
02A4:  DATA 50,72
02A6:  DATA 75,65
02A8:  DATA 62,61
02AA:  DATA 00,00
02AC:  DATA 50,72
02AE:  DATA 75,65
02B0:  DATA 62,61
02B2:  DATA 00,00
*
03E4:  TBLRD*+
03E6:  MOVF   FF5,F
03E8:  BZ    0404
03EA:  MOVFF  FF6,35
03EE:  MOVFF  FF7,36
03F2:  MOVF   FF5,W
03F4:  BTFSS  F9E.4
03F6:  BRA    03F4
03F8:  MOVWF  FAD
03FA:  MOVFF  35,FF6
03FE:  MOVFF  36,FF7
0402:  BRA    03E4
0404:  RETURN 0
0406:  TBLRD*+
0408:  MOVF   FF5,F
040A:  BZ    0430
040C:  MOVFF  FF6,35
0410:  MOVFF  FF7,36
0414:  CLRF   19
0416:  BTFSC  FF2.7
0418:  BSF    19.7
041A:  BCF    FF2.7
041C:  MOVFF  FF5,43
0420:  RCALL  0192
0422:  BTFSC  19.7
0424:  BSF    FF2.7
0426:  MOVFF  35,FF6
042A:  MOVFF  36,FF7
042E:  BRA    0406
0430:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
0370:  MOVFF  35,FE9
0374:  MOVFF  36,FEA
0378:  MOVFF  FEF,39
037C:  MOVFF  38,03
0380:  MOVFF  37,FE9
0384:  MOVFF  38,FEA
0388:  MOVF   FEF,W
038A:  SUBWF  39,W
038C:  BNZ   03B8
....................       if (*s1 == '\0') 
038E:  MOVFF  36,03
0392:  MOVFF  35,FE9
0396:  MOVFF  03,FEA
039A:  MOVF   FEF,F
039C:  BNZ   03A4
....................          return(0); 
039E:  MOVLW  00
03A0:  MOVWF  01
03A2:  BRA    03E2
03A4:  MOVFF  36,03
03A8:  MOVF   35,W
03AA:  INCF   35,F
03AC:  BTFSC  FD8.2
03AE:  INCF   36,F
03B0:  INCF   37,F
03B2:  BTFSC  FD8.2
03B4:  INCF   38,F
03B6:  BRA    0370
....................    return((*s1 < *s2) ? -1: 1); 
03B8:  MOVFF  36,03
03BC:  MOVFF  35,FE9
03C0:  MOVFF  36,FEA
03C4:  MOVFF  FEF,39
03C8:  MOVFF  38,03
03CC:  MOVFF  37,FE9
03D0:  MOVFF  38,FEA
03D4:  MOVF   FEF,W
03D6:  SUBWF  39,W
03D8:  BC    03DE
03DA:  MOVLW  FF
03DC:  BRA    03E0
03DE:  MOVLW  01
03E0:  MOVWF  01
03E2:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use delay(clock=4000000)			//Frecuencia de trabajo 
*
016A:  CLRF   FEA
016C:  MOVLW  44
016E:  MOVWF  FE9
0170:  MOVF   FEF,W
0172:  BZ    0190
0174:  MOVLW  01
0176:  MOVWF  01
0178:  CLRF   00
017A:  DECFSZ 00,F
017C:  BRA    017A
017E:  DECFSZ 01,F
0180:  BRA    0178
0182:  MOVLW  4A
0184:  MOVWF  00
0186:  DECFSZ 00,F
0188:  BRA    0186
018A:  BRA    018C
018C:  DECFSZ FEF,F
018E:  BRA    0174
0190:  RETURN 0
....................  
.................... #fuses 	EC_IO			//Oscilador externo, RA6=E/S,PLL OFF (CONFIG1H)	 
.................... #fuses 	CPUDIV1			//Postcaler OSC/1, Frec. CPU=4MHz/1=4MHz (CONFIG1L) 
.................... 						//Ciclo de instrucción = 1uS (1/(4000000/4)) 
....................  
.................... #fuses PUT,NOBROWNOUT,NOWDT,NOPBADEN,NOLVP 
....................  
.................... #define LCD_DATA_PORT getenv("SFR:PORTB")  
.................... #include <lcd.c> //No se usa fast_io en la puerta 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00BA:  MOVLW  0F
00BC:  ANDWF  F93,W
00BE:  IORLW  F0
00C0:  MOVWF  F93
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00C2:  BSF    F8A.2
....................    delay_cycles(1); 
00C4:  NOP   
....................    lcd_output_enable(1); 
00C6:  BSF    F8A.0
....................    delay_cycles(1); 
00C8:  NOP   
....................    high = lcd_read_nibble(); 
00CA:  RCALL  00AE
00CC:  MOVFF  01,4B
....................        
....................    lcd_output_enable(0); 
00D0:  BCF    F8A.0
....................    delay_cycles(1); 
00D2:  NOP   
....................    lcd_output_enable(1); 
00D4:  BSF    F8A.0
....................    delay_us(1); 
00D6:  NOP   
....................    low = lcd_read_nibble(); 
00D8:  RCALL  00AE
00DA:  MOVFF  01,4A
....................        
....................    lcd_output_enable(0); 
00DE:  BCF    F8A.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00E0:  MOVLW  0F
00E2:  ANDWF  F93,W
00E4:  MOVWF  F93
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00E6:  SWAPF  4B,W
00E8:  MOVWF  00
00EA:  MOVLW  F0
00EC:  ANDWF  00,F
00EE:  MOVF   00,W
00F0:  IORWF  4A,W
00F2:  MOVWF  01
00F4:  RETURN 0
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00AE:  MOVF   F81,W
00B0:  MOVWF  00
00B2:  SWAPF  00,W
00B4:  ANDLW  0F
00B6:  MOVWF  01
....................   #endif 
00B8:  RETURN 0
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
00F6:  SWAPF  4B,W
00F8:  ANDLW  F0
00FA:  MOVWF  00
00FC:  MOVLW  0F
00FE:  ANDWF  F8A,W
0100:  IORWF  00,W
0102:  MOVWF  F8A
....................   #endif 
....................        
....................    delay_cycles(1); 
0104:  NOP   
....................    lcd_output_enable(1); 
0106:  BSF    F8A.0
....................    delay_us(2); 
0108:  BRA    010A
....................    lcd_output_enable(0); 
010A:  BCF    F8A.0
010C:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
010E:  BCF    F93.0
....................    lcd_rs_tris(); 
0110:  BCF    F93.1
....................    lcd_rw_tris(); 
0112:  BCF    F93.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0114:  BCF    F8A.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
0116:  RCALL  00BA
0118:  MOVFF  01,4A
011C:  BTFSC  01.7
011E:  BRA    0116
....................    lcd_output_rs(address); 
0120:  BCF    F8A.1
0122:  BTFSC  48.0
0124:  BSF    F8A.1
....................    delay_cycles(1); 
0126:  NOP   
....................    lcd_output_rw(0); 
0128:  BCF    F8A.2
....................    delay_cycles(1); 
012A:  NOP   
....................    lcd_output_enable(0); 
012C:  BCF    F8A.0
....................    lcd_send_nibble(n >> 4); 
012E:  SWAPF  49,W
0130:  MOVWF  4A
0132:  MOVLW  0F
0134:  ANDWF  4A,F
0136:  MOVFF  4A,4B
013A:  RCALL  00F6
....................    lcd_send_nibble(n & 0xf); 
013C:  MOVF   49,W
013E:  ANDLW  0F
0140:  MOVWF  4A
0142:  MOVWF  4B
0144:  RCALL  00F6
0146:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
*
02B4:  MOVLW  28
02B6:  MOVWF  36
02B8:  MOVLW  0C
02BA:  MOVWF  37
02BC:  MOVLW  01
02BE:  MOVWF  38
02C0:  MOVLW  06
02C2:  MOVWF  39
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
02C4:  BCF    F8A.0
....................    lcd_output_rs(0); 
02C6:  BCF    F8A.1
....................    lcd_output_rw(0); 
02C8:  BCF    F8A.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
02CA:  MOVLW  0F
02CC:  ANDWF  F93,W
02CE:  MOVWF  F93
....................   #endif 
....................    lcd_enable_tris(); 
02D0:  BCF    F93.0
....................    lcd_rs_tris(); 
02D2:  BCF    F93.1
....................    lcd_rw_tris(); 
02D4:  BCF    F93.2
02D6:  CLRF   19
02D8:  BTFSC  FF2.7
02DA:  BSF    19.7
02DC:  BCF    FF2.7
....................  #endif 
....................      
....................    delay_ms(15); 
02DE:  MOVLW  0F
02E0:  MOVWF  44
02E2:  RCALL  016A
02E4:  BTFSC  19.7
02E6:  BSF    FF2.7
....................    for(i=1;i<=3;++i) 
02E8:  MOVLW  01
02EA:  MOVWF  35
02EC:  MOVF   35,W
02EE:  SUBLW  03
02F0:  BNC   031A
02F2:  CLRF   19
02F4:  BTFSC  FF2.7
02F6:  BSF    19.7
02F8:  BCF    FF2.7
....................    { 
....................        lcd_send_nibble(3); 
02FA:  MOVLW  03
02FC:  MOVWF  4B
02FE:  RCALL  00F6
0300:  BTFSC  19.7
0302:  BSF    FF2.7
0304:  CLRF   19
0306:  BTFSC  FF2.7
0308:  BSF    19.7
030A:  BCF    FF2.7
....................        delay_ms(5); 
030C:  MOVLW  05
030E:  MOVWF  44
0310:  RCALL  016A
0312:  BTFSC  19.7
0314:  BSF    FF2.7
0316:  INCF   35,F
0318:  BRA    02EC
031A:  CLRF   19
031C:  BTFSC  FF2.7
031E:  BSF    19.7
0320:  BCF    FF2.7
....................    } 
....................     
....................    lcd_send_nibble(2); 
0322:  MOVLW  02
0324:  MOVWF  4B
0326:  RCALL  00F6
0328:  BTFSC  19.7
032A:  BSF    FF2.7
032C:  CLRF   19
032E:  BTFSC  FF2.7
0330:  BSF    19.7
0332:  BCF    FF2.7
....................    delay_ms(5); 
0334:  MOVLW  05
0336:  MOVWF  44
0338:  RCALL  016A
033A:  BTFSC  19.7
033C:  BSF    FF2.7
....................    for(i=0;i<=3;++i) 
033E:  CLRF   35
0340:  MOVF   35,W
0342:  SUBLW  03
0344:  BNC   036C
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0346:  CLRF   03
0348:  MOVF   35,W
034A:  ADDLW  36
034C:  MOVWF  FE9
034E:  MOVLW  00
0350:  ADDWFC 03,W
0352:  MOVWF  FEA
0354:  MOVFF  FEF,49
0358:  CLRF   19
035A:  BTFSC  FF2.7
035C:  BSF    19.7
035E:  BCF    FF2.7
0360:  CLRF   48
0362:  RCALL  010E
0364:  BTFSC  19.7
0366:  BSF    FF2.7
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0368:  INCF   35,F
036A:  BRA    0340
036C:  GOTO   0512 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0148:  DECFSZ 45,W
014A:  BRA    014E
014C:  BRA    0154
....................       address=LCD_LINE_TWO; 
014E:  MOVLW  40
0150:  MOVWF  46
0152:  BRA    0156
....................    else 
....................       address=0; 
0154:  CLRF   46
....................       
....................    address+=x-1; 
0156:  MOVLW  01
0158:  SUBWF  44,W
015A:  ADDWF  46,F
....................    lcd_send_byte(0,0x80|address); 
015C:  MOVF   46,W
015E:  IORLW  80
0160:  MOVWF  47
0162:  CLRF   48
0164:  MOVWF  49
0166:  RCALL  010E
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0168:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
0192:  MOVF   43,W
0194:  XORLW  07
0196:  BZ    01A6
0198:  XORLW  0B
019A:  BZ    01B0
019C:  XORLW  06
019E:  BZ    01C0
01A0:  XORLW  02
01A2:  BZ    01CC
01A4:  BRA    01D6
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01A6:  MOVLW  01
01A8:  MOVWF  44
01AA:  MOVWF  45
01AC:  RCALL  0148
01AE:  BRA    01E0
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01B0:  CLRF   48
01B2:  MOVLW  01
01B4:  MOVWF  49
01B6:  RCALL  010E
....................                      delay_ms(2); 
01B8:  MOVLW  02
01BA:  MOVWF  44
01BC:  RCALL  016A
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01BE:  BRA    01E0
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01C0:  MOVLW  01
01C2:  MOVWF  44
01C4:  MOVLW  02
01C6:  MOVWF  45
01C8:  RCALL  0148
01CA:  BRA    01E0
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01CC:  CLRF   48
01CE:  MOVLW  10
01D0:  MOVWF  49
01D2:  RCALL  010E
01D4:  BRA    01E0
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01D6:  MOVLW  01
01D8:  MOVWF  48
01DA:  MOVFF  43,49
01DE:  RCALL  010E
....................      #endif 
....................    } 
01E0:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... //Habilita las funciones RS232, velocidad a 9600 baudios 
.................... #use rs232(Baud=9600,xmit=PIN_C6, rcv=PIN_C7) 
*
04CC:  BTFSS  F9E.4
04CE:  BRA    04CC
04D0:  MOVWF  FAD
04D2:  RETURN 0
....................  
.................... #use fast_io (C) 
....................  
.................... char dato[10];		//Variable para almacena el dato recibido 
.................... char ok[10]="OK\r"; 
.................... char c; 
.................... int comp; 
....................  
.................... #int_rda			//Vector de interrupción al recibir por el UART 
.................... tratamiento(){	 
.................... 	gets(dato);	//Lee el dato recibido hasta el enter<CR> (13) 
*
0208:  CLRF   FEA
020A:  MOVLW  1C
020C:  MOVWF  FE9
020E:  CLRF   FED
0210:  BTFSS  F9E.5
0212:  BRA    0210
0214:  MOVFF  FAE,FEC
0218:  MOVLW  0D
021A:  SUBWF  FEF,W
021C:  BNZ   0210
021E:  CLRF   FEC
.................... 	//c = getc(); 
.................... 	lcd_gotoxy(1,2); 
0220:  MOVLW  01
0222:  MOVWF  44
0224:  MOVLW  02
0226:  MOVWF  45
0228:  RCALL  0148
.................... 	printf(lcd_putc, "%s", dato); 
022A:  CLRF   FEA
022C:  MOVLW  1C
022E:  MOVWF  FE9
0230:  BRA    01E2
.................... 	//printf(lcd_putc, "%d", c); 
0232:  BCF    F9E.5
0234:  GOTO   0060
.................... }	 
....................  
.................... void initSim800(){ 
.................... 	disable_interrupts(global); // RS232 OFF 
*
0432:  BCF    FF2.6
0434:  BCF    FF2.7
0436:  BTFSC  FF2.7
0438:  BRA    0434
.................... 	comp = strcmp(ok, dato); 
043A:  CLRF   36
043C:  MOVLW  26
043E:  MOVWF  35
0440:  CLRF   38
0442:  MOVLW  1C
0444:  MOVWF  37
0446:  RCALL  0370
0448:  MOVFF  01,31
.................... 	while(strcmp(ok, dato) != 0){ 
044C:  CLRF   36
044E:  MOVLW  26
0450:  MOVWF  35
0452:  CLRF   38
0454:  MOVLW  1C
0456:  MOVWF  37
0458:  RCALL  0370
045A:  MOVF   01,F
045C:  BZ    04A6
.................... 		printf("AT\r"); 
045E:  MOVLW  38
0460:  MOVWF  FF6
0462:  MOVLW  02
0464:  MOVWF  FF7
0466:  RCALL  03E4
0468:  CLRF   19
046A:  BTFSC  FF2.7
046C:  BSF    19.7
046E:  BCF    FF2.7
.................... 		delay_ms(100); 
0470:  MOVLW  64
0472:  MOVWF  44
0474:  RCALL  016A
0476:  BTFSC  19.7
0478:  BSF    FF2.7
.................... 		gets(dato); 
047A:  CLRF   FEA
047C:  MOVLW  1C
047E:  MOVWF  FE9
0480:  CLRF   FED
0482:  BTFSS  F9E.5
0484:  BRA    0482
0486:  MOVFF  FAE,FEC
048A:  MOVLW  0D
048C:  SUBWF  FEF,W
048E:  BNZ   0482
0490:  CLRF   FEC
.................... 		comp = strcmp(ok, dato); 
0492:  CLRF   36
0494:  MOVLW  26
0496:  MOVWF  35
0498:  CLRF   38
049A:  MOVLW  1C
049C:  MOVWF  37
049E:  RCALL  0370
04A0:  MOVFF  01,31
04A4:  BRA    044C
.................... 	} 
.................... 	enable_interrupts(global);		//Activa interrupción en la recepción 
04A6:  MOVLW  C0
04A8:  IORWF  FF2,F
04AA:  CLRF   19
04AC:  BTFSC  FF2.7
04AE:  BSF    19.7
04B0:  BCF    FF2.7
.................... 	lcd_gotoxy(1,1); 
04B2:  MOVLW  01
04B4:  MOVWF  44
04B6:  MOVWF  45
04B8:  RCALL  0148
04BA:  BTFSC  19.7
04BC:  BSF    FF2.7
.................... 	printf(lcd_putc, "TODO BIEN"); 
04BE:  MOVLW  3C
04C0:  MOVWF  FF6
04C2:  MOVLW  02
04C4:  MOVWF  FF7
04C6:  RCALL  0406
04C8:  GOTO   051A (RETURN)
.................... } 
....................  
.................... void main(){ 
*
04D4:  CLRF   FF8
04D6:  BCF    FD0.7
04D8:  BSF    07.7
04DA:  BCF    FB8.3
04DC:  MOVLW  19
04DE:  MOVWF  FAF
04E0:  MOVLW  A6
04E2:  MOVWF  FAC
04E4:  MOVLW  90
04E6:  MOVWF  FAB
04E8:  CLRF   33
04EA:  CLRF   32
04EC:  MOVF   FC1,W
04EE:  ANDLW  C0
04F0:  IORLW  0F
04F2:  MOVWF  FC1
04F4:  MOVLW  07
04F6:  MOVWF  FB4
04F8:  CLRF   1A
04FA:  CLRF   1B
04FC:  MOVLW  4F
04FE:  MOVWF  26
0500:  MOVLW  4B
0502:  MOVWF  27
0504:  MOVLW  0D
0506:  MOVWF  28
0508:  CLRF   29
050A:  CLRF   34
.................... 	int cont=0; 
.................... 	set_tris_c(0b10111111);	//RC7/Rx entrada, RC6/Tx salida	 
050C:  MOVLW  BF
050E:  MOVWF  F94
.................... 	//setup_uart(uart_autodetect);	//Activa ciclo de auto detección de baudios 
.................... 	lcd_init(); 
0510:  BRA    02B4
.................... 	enable_interrupts(INT_RDA);		//Activa interrupción en la recepción 
0512:  BSF    F9D.5
.................... 	enable_interrupts(global);		//Habilita interrupciones 
0514:  MOVLW  C0
0516:  IORWF  FF2,F
.................... 	 
.................... 	initSim800(); 
0518:  BRA    0432
051A:  CLRF   19
051C:  BTFSC  FF2.7
051E:  BSF    19.7
0520:  BCF    FF2.7
.................... 	 
.................... 	lcd_gotoxy(1,1); 
0522:  MOVLW  01
0524:  MOVWF  44
0526:  MOVWF  45
0528:  RCALL  0148
052A:  BTFSC  19.7
052C:  BSF    FF2.7
.................... 	printf(lcd_putc, "AT+CMGS=?"); 
052E:  MOVLW  46
0530:  MOVWF  FF6
0532:  MOVLW  02
0534:  MOVWF  FF7
0536:  RCALL  0406
.................... 	printf("AT+CMGS=?\r"); //Tiene que responder OK 
0538:  MOVLW  50
053A:  MOVWF  FF6
053C:  MOVLW  02
053E:  MOVWF  FF7
0540:  RCALL  03E4
.................... 	delay_ms(1000); 
0542:  MOVLW  04
0544:  MOVWF  35
0546:  CLRF   19
0548:  BTFSC  FF2.7
054A:  BSF    19.7
054C:  BCF    FF2.7
054E:  MOVLW  FA
0550:  MOVWF  44
0552:  RCALL  016A
0554:  BTFSC  19.7
0556:  BSF    FF2.7
0558:  DECFSZ 35,F
055A:  BRA    0546
055C:  CLRF   19
055E:  BTFSC  FF2.7
0560:  BSF    19.7
0562:  BCF    FF2.7
....................  
.................... 	lcd_gotoxy(1,1); 
0564:  MOVLW  01
0566:  MOVWF  44
0568:  MOVWF  45
056A:  RCALL  0148
056C:  BTFSC  19.7
056E:  BSF    FF2.7
.................... 	printf(lcd_putc, "AT+CMGF=1"); 
0570:  MOVLW  5C
0572:  MOVWF  FF6
0574:  MOVLW  02
0576:  MOVWF  FF7
0578:  RCALL  0406
.................... 	printf("AT+CMGF=1\r"); //Modo texto 
057A:  MOVLW  66
057C:  MOVWF  FF6
057E:  MOVLW  02
0580:  MOVWF  FF7
0582:  RCALL  03E4
.................... 	delay_ms(1000); 
0584:  MOVLW  04
0586:  MOVWF  35
0588:  CLRF   19
058A:  BTFSC  FF2.7
058C:  BSF    19.7
058E:  BCF    FF2.7
0590:  MOVLW  FA
0592:  MOVWF  44
0594:  RCALL  016A
0596:  BTFSC  19.7
0598:  BSF    FF2.7
059A:  DECFSZ 35,F
059C:  BRA    0588
059E:  CLRF   19
05A0:  BTFSC  FF2.7
05A2:  BSF    19.7
05A4:  BCF    FF2.7
....................  
.................... 	lcd_gotoxy(1,1); 
05A6:  MOVLW  01
05A8:  MOVWF  44
05AA:  MOVWF  45
05AC:  RCALL  0148
05AE:  BTFSC  19.7
05B0:  BSF    FF2.7
.................... 	printf(lcd_putc, "AT+CMGS=\"+593959984110\""); 
05B2:  MOVLW  72
05B4:  MOVWF  FF6
05B6:  MOVLW  02
05B8:  MOVWF  FF7
05BA:  RCALL  0406
.................... 	printf("AT+CMGS=\"+593959984110\"\r"); //Numero de telefono 
05BC:  MOVLW  8A
05BE:  MOVWF  FF6
05C0:  MOVLW  02
05C2:  MOVWF  FF7
05C4:  RCALL  03E4
.................... 	delay_ms(1000); 
05C6:  MOVLW  04
05C8:  MOVWF  35
05CA:  CLRF   19
05CC:  BTFSC  FF2.7
05CE:  BSF    19.7
05D0:  BCF    FF2.7
05D2:  MOVLW  FA
05D4:  MOVWF  44
05D6:  RCALL  016A
05D8:  BTFSC  19.7
05DA:  BSF    FF2.7
05DC:  DECFSZ 35,F
05DE:  BRA    05CA
05E0:  CLRF   19
05E2:  BTFSC  FF2.7
05E4:  BSF    19.7
05E6:  BCF    FF2.7
....................  
.................... 	lcd_gotoxy(1,1); 
05E8:  MOVLW  01
05EA:  MOVWF  44
05EC:  MOVWF  45
05EE:  RCALL  0148
05F0:  BTFSC  19.7
05F2:  BSF    FF2.7
.................... 	printf(lcd_putc, "Prueba"); 
05F4:  MOVLW  A4
05F6:  MOVWF  FF6
05F8:  MOVLW  02
05FA:  MOVWF  FF7
05FC:  RCALL  0406
.................... 	printf("Prueba"); //Mensaje 
05FE:  MOVLW  AC
0600:  MOVWF  FF6
0602:  MOVLW  02
0604:  MOVWF  FF7
0606:  RCALL  03E4
.................... 	putc(26); // CTRL+Z 
0608:  MOVLW  1A
060A:  RCALL  04CC
.................... 	putc('\r'); 
060C:  MOVLW  0D
060E:  RCALL  04CC
.................... 	delay_ms(1000); 
0610:  MOVLW  04
0612:  MOVWF  35
0614:  CLRF   19
0616:  BTFSC  FF2.7
0618:  BSF    19.7
061A:  BCF    FF2.7
061C:  MOVLW  FA
061E:  MOVWF  44
0620:  RCALL  016A
0622:  BTFSC  19.7
0624:  BSF    FF2.7
0626:  DECFSZ 35,F
0628:  BRA    0614
....................  
.................... 	while(1) 
.................... 	{	 
062A:  BRA    062A
.................... 		 
.................... 	} 
.................... } 
062C:  SLEEP 

Configuration Fuses:
   Word  1: C427   PLL12 CPUDIV1 USBDIV EC_IO FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
