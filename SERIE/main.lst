CCS PCH C Compiler, Version 5.070, 56587               24-sep-17 16:15

               Filename:   D:\PIC\SIM800L-18F\SERIE\main.lst

               ROM used:   1544 bytes (5%)
                           Largest free fragment is 31220
               RAM used:   54 (3%) at main() level
                           77 (4%) worst case
               Stack used: 10 locations (4 in main + 6 for interrupts)
               Stack size: 31

*
0000:  GOTO   04B2
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.5
0056:  GOTO   0060
005A:  BTFSC  F9E.5
005C:  GOTO   0208
0060:  MOVFF  0E,00
0064:  MOVFF  0F,01
0068:  MOVFF  10,02
006C:  MOVFF  11,03
0070:  MOVFF  0C,FE9
0074:  MOVFF  07,FEA
0078:  BSF    07.7
007A:  MOVFF  08,FE1
007E:  MOVFF  09,FE2
0082:  MOVFF  0A,FD9
0086:  MOVFF  0B,FDA
008A:  MOVFF  12,FF3
008E:  MOVFF  13,FF4
0092:  MOVFF  14,FFA
0096:  MOVFF  15,FF5
009A:  MOVFF  16,FF6
009E:  MOVFF  17,FF7
00A2:  MOVF   04,W
00A4:  MOVFF  06,FE0
00A8:  MOVFF  05,FD8
00AC:  RETFIE 0
.................... #include <18f2550.h>	//Tipo de procesador 
.................... //////////// Standard Header file for the PIC18F2550 device //////////////// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... #device PIC18F2550 
*
01E2:  MOVF   FEF,F
01E4:  BZ    0204
01E6:  MOVFF  FEA,42
01EA:  MOVFF  FE9,41
01EE:  MOVFF  FEF,43
01F2:  RCALL  0192
01F4:  MOVFF  42,FEA
01F8:  MOVFF  41,FE9
01FC:  INCF   FE9,F
01FE:  BTFSC  FD8.2
0200:  INCF   FEA,F
0202:  BRA    01E2
0204:  GOTO   0232 (RETURN)
*
0238:  DATA 41,54
023A:  DATA 0D,00
023C:  DATA 41,54
023E:  DATA 2B,49
0240:  DATA 50,52
0242:  DATA 0D,00
0244:  DATA 41,54
0246:  DATA 2B,43
0248:  DATA 4D,47
024A:  DATA 53,3D
024C:  DATA 3F,00
024E:  DATA 41,54
0250:  DATA 2B,43
0252:  DATA 4D,47
0254:  DATA 53,3D
0256:  DATA 3F,0D
0258:  DATA 00,00
025A:  DATA 41,54
025C:  DATA 2B,43
025E:  DATA 4D,47
0260:  DATA 46,3D
0262:  DATA 31,00
0264:  DATA 41,54
0266:  DATA 2B,43
0268:  DATA 4D,47
026A:  DATA 46,3D
026C:  DATA 31,0D
026E:  DATA 00,00
0270:  DATA 41,54
0272:  DATA 2B,43
0274:  DATA 4D,47
0276:  DATA 53,3D
0278:  DATA 22,2B
027A:  DATA 35,39
027C:  DATA 33,39
027E:  DATA 35,39
0280:  DATA 39,38
0282:  DATA 34,31
0284:  DATA 31,30
0286:  DATA 22,00
0288:  DATA 41,54
028A:  DATA 2B,43
028C:  DATA 4D,47
028E:  DATA 53,3D
0290:  DATA 22,2B
0292:  DATA 35,39
0294:  DATA 33,39
0296:  DATA 35,39
0298:  DATA 39,38
029A:  DATA 34,31
029C:  DATA 31,30
029E:  DATA 22,0D
02A0:  DATA 00,00
02A2:  DATA 50,72
02A4:  DATA 75,65
02A6:  DATA 62,61
02A8:  DATA 00,00
02AA:  DATA 50,72
02AC:  DATA 75,65
02AE:  DATA 62,61
02B0:  DATA 00,00
*
03E2:  TBLRD*+
03E4:  MOVF   FF5,F
03E6:  BZ    0402
03E8:  MOVFF  FF6,35
03EC:  MOVFF  FF7,36
03F0:  MOVF   FF5,W
03F2:  BTFSS  F9E.4
03F4:  BRA    03F2
03F6:  MOVWF  FAD
03F8:  MOVFF  35,FF6
03FC:  MOVFF  36,FF7
0400:  BRA    03E2
0402:  RETURN 0
*
047E:  TBLRD*+
0480:  MOVF   FF5,F
0482:  BZ    04A8
0484:  MOVFF  FF6,35
0488:  MOVFF  FF7,36
048C:  CLRF   19
048E:  BTFSC  FF2.7
0490:  BSF    19.7
0492:  BCF    FF2.7
0494:  MOVFF  FF5,43
0498:  RCALL  0192
049A:  BTFSC  19.7
049C:  BSF    FF2.7
049E:  MOVFF  35,FF6
04A2:  MOVFF  36,FF7
04A6:  BRA    047E
04A8:  RETURN 0
....................  
.................... #list 
....................  
.................... #include <string.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2008 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STRING 
.................... #define _STRING 
.................... #include <stddef.h> 
.................... /////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _STDDEF 
....................  
.................... #define _STDDEF 
....................  
.................... #if sizeof(unsigned int8 *)==1 
.................... #define ptrdiff_t unsigned int8 
.................... #else 
.................... #define ptrdiff_t unsigned int16 
.................... #endif 
....................  
.................... #if defined(__PCB__) || defined(__PCM__) 
.................... #define size_t unsigned int8 
.................... #else 
.................... #define size_t unsigned int16 
.................... #endif 
.................... #define wchar_t char 
.................... #define NULL 0 
....................  
.................... #define offsetof(s,f) (offsetofbit(s,f)/8) 
....................  
.................... #endif 
....................  
.................... #include <ctype.h> 
.................... //////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2003 Custom Computer Services            //// 
.................... //// This source code may only be used by licensed users of the CCS C   //// 
.................... //// compiler.  This source code may only be distributed to other       //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction  //// 
.................... //// or distribution is permitted without written permission.           //// 
.................... //// Derivative programs created using this software in object code     //// 
.................... //// form are not restricted in any way.                                //// 
.................... //////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef _CTYPE 
.................... #define _CTYPE 
....................  
.................... #define islower(x)  isamong(x,"abcdefghijklmnopqrstuvwxyz") 
.................... #define isupper(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZ") 
.................... #define isalnum(x)  isamong(x,"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isalpha(x)  isamong(x,"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz") 
.................... #define isdigit(x)  isamong(x,"0123456789") 
.................... #define isspace(x)  ((x)==' ') 
.................... #define isxdigit(x) isamong(x,"0123456789ABCDEFabcdef") 
.................... #define iscntrl(x)  ((x)<' ') 
.................... #define isprint(x)  ((x)>=' ') 
.................... #define isgraph(x)  ((x)>' ') 
.................... #define ispunct(x)  (((x)>' ')&&!isalnum(x)) 
....................  
.................... #endif 
....................  
....................  
....................  
....................  
....................  
.................... ////////////////////////////////////////////// 
.................... //// Uncomment the following define to    //// 
.................... //// allow some functions to use a        //// 
.................... //// quicker algorithm, but use more ROM  //// 
.................... ////                                      //// 
.................... //// #define FASTER_BUT_MORE_ROM          //// 
.................... ////////////////////////////////////////////// 
....................  
....................  
....................  
.................... /*Copying functions*/ 
.................... /* standard template: 
....................    void *memmove(void *s1, void *s2, size_t n). 
....................    Copies max of n characters safely (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *memmove(void *s1,void *s2,size_t n) 
.................... { 
....................    unsigned char *sc1; 
....................    unsigned char *sc2; 
....................    sc1=s1; 
....................    sc2=s2; 
....................    if(sc2<sc1 && sc1 <sc2 +n) 
....................       for(sc1+=n,sc2+=n;0<n;--n) 
....................          *--sc1=*--sc2; 
....................    else 
....................       for(;0<n;--n) 
....................          *sc1++=*sc2++; 
....................   return s1; 
....................   } 
....................  
.................... /* Standard template: char *strcpy(char *s1, const char *s2) 
....................    copies the string s2 including the null character to s1. 
....................    This is a compiler built in to handle the different address 
....................    spaces */ 
....................  
.................... #define strcopy strcpy 
....................  
.................... /* standard template: 
....................    char *strncpy(char *s1, const char *s2, size_t n). 
....................    Copies max of n characters (not following ending '\0') 
....................    from s2 in s1; if s2 has less than n characters, appends 0 */ 
....................  
.................... unsigned char *strncpy(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................   unsigned char *s; 
....................  
....................   for (s = s1; n > 0 && *s2 != '\0'; n--) 
....................      *s++ = *s2++; 
....................   for (; n > 0; n--) 
....................      *s++ = '\0'; 
....................  
....................   return(s1); 
.................... } 
.................... /***********************************************************/ 
....................  
.................... /*concatenation functions*/ 
.................... /* standard template: char *strcat(char *s1, const char *s2) 
.................... appends s2 to s1*/ 
....................  
.................... unsigned char *strcat(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0') 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
.................... /* standard template: char *strncat(char *s1, char *s2,size_t n) 
.................... appends not more than n characters from s2 to s1*/ 
....................  
.................... unsigned char *strncat(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char *s; 
....................  
....................    for (s = s1; *s != '\0'; ++s); 
....................    while(*s2 != '\0' && 0<n) 
....................    { 
....................       *s = *s2; 
....................       ++s; 
....................       ++s2; 
....................       --n; 
....................    } 
....................  
....................    *s = '\0'; 
....................    return(s1); 
.................... } 
....................  
.................... /***********************************************************/ 
....................  
....................  
.................... /*comparison functions*/ 
.................... /* standard template: signed int memcmp(void *s1, void *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 memcmp(void * s1,void *s2,size_t n) 
.................... { 
.................... unsigned char *su1, *su2; 
.................... for(su1=s1, su2=s2; 0<n; ++su1, ++su2, --n) 
.................... { 
....................    if(*su1!=*su2) 
....................       return ((*su1<*su2)?-1:1); 
.................... } 
.................... return 0; 
.................... } 
....................  
.................... /* standard template: int strcmp(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
*
036E:  MOVFF  35,FE9
0372:  MOVFF  36,FEA
0376:  MOVFF  FEF,39
037A:  MOVFF  38,03
037E:  MOVFF  37,FE9
0382:  MOVFF  38,FEA
0386:  MOVF   FEF,W
0388:  SUBWF  39,W
038A:  BNZ   03B6
....................       if (*s1 == '\0') 
038C:  MOVFF  36,03
0390:  MOVFF  35,FE9
0394:  MOVFF  03,FEA
0398:  MOVF   FEF,F
039A:  BNZ   03A2
....................          return(0); 
039C:  MOVLW  00
039E:  MOVWF  01
03A0:  BRA    03E0
03A2:  MOVFF  36,03
03A6:  MOVF   35,W
03A8:  INCF   35,F
03AA:  BTFSC  FD8.2
03AC:  INCF   36,F
03AE:  INCF   37,F
03B0:  BTFSC  FD8.2
03B2:  INCF   38,F
03B4:  BRA    036E
....................    return((*s1 < *s2) ? -1: 1); 
03B6:  MOVFF  36,03
03BA:  MOVFF  35,FE9
03BE:  MOVFF  36,FEA
03C2:  MOVFF  FEF,39
03C6:  MOVFF  38,03
03CA:  MOVFF  37,FE9
03CE:  MOVFF  38,FEA
03D2:  MOVF   FEF,W
03D4:  SUBWF  39,W
03D6:  BC    03DC
03D8:  MOVLW  FF
03DA:  BRA    03DE
03DC:  MOVLW  01
03DE:  MOVWF  01
03E0:  RETURN 0
.................... } 
.................... /* standard template: int strcoll(const char *s1, const char *s2). 
....................    Compares s1 & s2; returns -1 if s1<s2, 0 if s1=s2, 1 if s1>s2 */ 
....................  
.................... signed int8 strcoll(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    for (; *s1 == *s2; s1++, s2++) 
....................       if (*s1 == '\0') 
....................          return(0); 
....................    return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
.................... /* standard template: 
....................    int strncmp(const char *s1, const char *s2, size_t n). 
....................    Compares max of n characters (not following 0) from s1 to s2; 
....................    returns same as strcmp */ 
....................  
.................... signed int8 strncmp(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    for (; n > 0; s1++, s2++, n--) 
....................       if (*s1 != *s2) 
....................          return((*s1 <*s2) ? -1: 1); 
....................       else if (*s1 == '\0') 
....................          return(0); 
....................    return(0); 
.................... } 
.................... /* standard template: 
....................    int strxfrm(const char *s1, const char *s2, size_t n). 
....................    transforms maximum of n characters from s2 and places them into s1, returns number of chars written ot s1. 
....................    if s1 is NULL and n is 0, then it returns the length of s2.*/ 
.................... size_t strxfrm(unsigned char *s1, unsigned char *s2, size_t n) 
.................... { 
....................    unsigned char c; 
....................    unsigned int8 n1; 
....................     
....................    if (!s1 && !n) 
....................       n = -1; //find length 
....................  
....................    n1 = 0; 
....................     
....................    for (; n1 < n; n1++) 
....................    { 
....................       c = *s2++; 
....................       if (!c) 
....................          break; 
....................       if (s1) 
....................          *s1++ = c; 
....................    } 
....................  
....................   return(n1); 
.................... } 
....................  
....................  
....................  
....................  
....................  
.................... /***********************************************************/ 
.................... /*Search functions*/ 
.................... /* standard template: void *memchr(const char *s, int c). 
....................    Finds first occurrence of c in n characters of s */ 
....................  
.................... unsigned char *memchr(void *s,unsigned int8 c,size_t n) 
.................... { 
....................    unsigned char uc; 
....................    unsigned char *su; 
....................    uc=c; 
....................    for(su=s;0<n;++su,--n) 
....................       if(*su==uc) 
....................       return su; 
....................    return NULL; 
.................... } 
....................  
.................... /* standard template: char *strchr(const char *s, int c). 
....................    Finds first occurrence of c in s */ 
....................  
.................... unsigned char *strchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    for (; *s != c; s++) 
....................       if (*s == '\0') 
....................          return(0); 
....................    return(s); 
.................... } 
.................... /* standard template: 
....................    size_t strcspn(const char *s1, const char *s2). 
....................    Computes length of max initial segment of s1 that 
....................    consists entirely of characters NOT from s2*/ 
....................  
.................... unsigned int8  strcspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1 - s1); 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strpbrk(const char *s1, const char *s2). 
....................    Locates first occurence of any character from s2 in s1; 
....................    returns s1 if s2 is empty string */ 
....................  
.................... unsigned char *strpbrk(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; *sc2 != 0; sc2++) 
....................          if (*sc1 == *sc2) 
....................             return(sc1); 
....................    return(0); 
.................... } 
....................  
....................  
.................... /* standard template: char *strrchr(const char *s, int c). 
....................    Finds last occurrence of c in s */ 
....................  
.................... unsigned char *strrchr(unsigned char *s, unsigned int8 c) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = 0; ; s++) 
....................    { 
....................       if (*s == c) 
....................          p = s; 
....................       if (*s == '\0') 
....................          return(p); 
....................    } 
.................... } 
.................... /* computes length of max initial segment of s1 consisting 
....................    entirely of characters from s2 */ 
....................  
.................... unsigned int8  strspn(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *sc1, *sc2; 
....................  
....................    for (sc1 = s1; *sc1 != 0; sc1++) 
....................       for (sc2 = s2; ; sc2++) 
....................     if (*sc2 == '\0') 
....................        return(sc1 - s1); 
....................          else if (*sc1 == *sc2) 
....................             break; 
....................    return(sc1 - s1); 
.................... } 
.................... /* standard template: 
....................    char *strstr(const char *s1, const char *s2); 
....................    Locates first occurence of character sequence s2 in s1; 
....................    returns 0 if s2 is empty string 
....................  
....................    Uncomment #define FASTER_BUT_MORE_ROM at the top of the 
....................    file to use the faster algorithm */ 
.................... unsigned char *strstr(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *s, *t; 
....................  
....................    #ifdef FASTER_BUT_MORE_ROM 
....................    if (*s2 == '\0') 
....................          return(s1); 
....................    #endif 
....................  
....................    while (*s1) 
....................    { 
....................       for(s = s1, t = s2; *t && (*s == *t); ++s, ++t); 
....................  
....................       if (*t == '\0') 
....................          return s1; 
....................       ++s1; 
....................       #ifdef FASTER_BUT_MORE_ROM 
....................          while(*s1 != '\0' && *s1 != *s2) 
....................             ++s1; 
....................       #endif 
....................    } 
....................    return 0; 
.................... } 
....................  
.................... /* standard template: size_t strlen(const char *s). 
....................    Computes length of s1 (preceding terminating 0) */ 
....................  
.................... size_t strlen(unsigned char *s) 
.................... { 
....................    unsigned char *sc; 
....................  
....................    for (sc = s; *sc != 0; sc++); 
....................    return(sc - s); 
.................... } 
....................  
.................... /* standard template: char *strtok(char *s1, const char *s2). 
....................  
....................    Finds next token in s1 delimited by a character from separator 
....................    string s2 (which can be different from call to call).  First call 
....................    starts at beginning of s1 searching for first character NOT 
....................    contained in s2; returns 0 if none is found. 
....................    If one is found, it is the start of first token (return value). 
....................    Function then searches from there for a character contained in s2. 
....................    If none is found, current token extends to end of s1, and subsequent 
....................    searches for a token will return 0.  If one is found, it is 
....................    overwritten by '\0', which terminates current token.  Function saves 
....................    pointer to following character from which next search will start. 
....................    Each subsequent call, with 0 as first argument, starts searching 
....................    from saved pointer */ 
....................  
.................... unsigned char *strtok(unsigned char *s1, unsigned char *s2) 
.................... { 
....................    unsigned char *beg, *end; 
....................    static char *save; 
....................  
....................    beg = (s1)? s1: save; 
....................    beg += strspn(beg, s2); 
....................    if (*beg == '\0') 
....................       return(0); 
....................        
....................    end = strpbrk(beg, s2); 
....................    if (end != '\0') 
....................    { 
....................       *end = '\0'; 
....................       end++; 
....................       save = end; 
....................    } 
....................    else 
....................       save = beg + strlen(beg); 
....................     
....................    return(beg); 
.................... } 
....................  
.................... /*****************************************************************/ 
.................... /*Miscellaneous functions*/ 
.................... /* standard template 
.................... maps error number in errnum to an error message string 
.................... Returns: Pointer to string 
.................... */ 
.................... #ifdef _ERRNO 
.................... unsigned char * strerror(unsigned int8 errnum) 
.................... { 
.................... static unsigned char s[13]; 
.................... switch( errnum) 
.................... { 
.................... case 0: 
....................    strcpy(s,"no errors"); 
....................    return s; 
.................... case EDOM : 
....................    strcpy(s,"domain error"); 
....................    return s; 
.................... case ERANGE: 
....................    strcpy(s,"range error"); 
....................    return s; 
.................... } 
.................... } 
.................... #ENDIF 
....................  
.................... /* standard template: size_t stricmp(const char *s1, const char *s2). 
....................    Compares s1 to s2 ignoring case (upper vs. lower) */ 
....................  
.................... signed int8 stricmp(unsigned char *s1, unsigned char *s2) 
.................... { 
....................  for(; *s1==*s2||(isalpha(*s1)&&isalpha(*s2)&&(*s1==*s2+32||*s2==*s1+32)); 
....................     s1++, s2++) 
....................     if (*s1 == '\0') 
....................        return(0); 
....................  return((*s1 < *s2) ? -1: 1); 
.................... } 
....................  
....................  
.................... /* standard template: char *strlwr(char *s). 
....................    Replaces uppercase letters by lowercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strlwr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'A' && *p <='Z') 
....................          *p += 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
.................... /* standard template: char *strupr(char *s). 
....................    Replaces lowercase letters by upercase; 
....................    returns pointer to new string s */ 
....................  
.................... unsigned char *strupr(unsigned char *s) 
.................... { 
....................    unsigned char *p; 
....................  
....................    for (p = s; *p != '\0'; p++) 
....................       if (*p >= 'a' && *p <='z') 
....................          *p -= 'a' - 'A'; 
....................    return(s); 
.................... } 
....................  
....................  
.................... /************************************************************/ 
....................  
....................  
.................... #endif 
....................  
....................  
.................... #use delay(clock=4000000)			//Frecuencia de trabajo 
*
016A:  CLRF   FEA
016C:  MOVLW  44
016E:  MOVWF  FE9
0170:  MOVF   FEF,W
0172:  BZ    0190
0174:  MOVLW  01
0176:  MOVWF  01
0178:  CLRF   00
017A:  DECFSZ 00,F
017C:  BRA    017A
017E:  DECFSZ 01,F
0180:  BRA    0178
0182:  MOVLW  4A
0184:  MOVWF  00
0186:  DECFSZ 00,F
0188:  BRA    0186
018A:  BRA    018C
018C:  DECFSZ FEF,F
018E:  BRA    0174
0190:  RETURN 0
....................  
.................... #fuses 	EC_IO			//Oscilador externo, RA6=E/S,PLL OFF (CONFIG1H)	 
.................... #fuses 	CPUDIV1			//Postcaler OSC/1, Frec. CPU=4MHz/1=4MHz (CONFIG1L) 
.................... 						//Ciclo de instrucción = 1uS (1/(4000000/4)) 
....................  
.................... #fuses PUT,NOBROWNOUT,NOWDT,NOPBADEN,NOLVP 
....................  
.................... #define LCD_DATA_PORT getenv("SFR:PORTB")  
.................... #include <lcd.c> //No se usa fast_io en la puerta 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////                             LCD.C                                     //// 
.................... ////                 Driver for common LCD modules                         //// 
.................... ////                                                                       //// 
.................... ////  lcd_init()   Must be called before any other function.               //// 
.................... ////                                                                       //// 
.................... ////  lcd_putc(c)  Will display c on the next position of the LCD.         //// 
.................... ////                 \a  Set cursor position to upper left                 //// 
.................... ////                 \f  Clear display, set cursor to upper left           //// 
.................... ////                 \n  Go to start of second line                        //// 
.................... ////                 \b  Move back one position                            //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \n character     //// 
.................... ////              will erase all remanining characters on the current      //// 
.................... ////              line, and move the cursor to the beginning of the next   //// 
.................... ////              line.                                                    //// 
.................... ////              If LCD_EXTENDED_NEWLINE is defined, the \r character     //// 
.................... ////              will move the cursor to the start of the current         //// 
.................... ////              line.                                                    //// 
.................... ////                                                                       //// 
.................... ////  lcd_gotoxy(x,y) Set write position on LCD (upper left is 1,1)        //// 
.................... ////                                                                       //// 
.................... ////  lcd_getc(x,y)   Returns character at position x,y on LCD             //// 
.................... ////                                                                       //// 
.................... ////  lcd_cursor_on(int1 on)   Turn the cursor on (on=TRUE) or off         //// 
.................... ////              (on=FALSE).                                              //// 
.................... ////                                                                       //// 
.................... ////  lcd_set_cgram_char(w, *p)   Write a custom character to the CGRAM.   //// 
.................... ////                                                                       //// 
.................... ////                                                                       //// 
.................... ////  CONFIGURATION                                                        //// 
.................... ////  The LCD can be configured in one of two ways: a.) port access or     //// 
.................... ////  b.) pin access.  Port access requires the entire 7 bit interface     //// 
.................... ////  connected to one GPIO port, and the data bits (D4:D7 of the LCD)     //// 
.................... ////  connected to sequential pins on the GPIO.  Pin access                //// 
.................... ////  has no requirements, all 7 bits of the control interface can         //// 
.................... ////  can be connected to any GPIO using several ports.                    //// 
.................... ////                                                                       //// 
.................... ////  To use port access, #define LCD_DATA_PORT to the SFR location of     //// 
.................... ////  of the GPIO port that holds the interface, -AND- edit LCD_PIN_MAP    //// 
.................... ////  of this file to configure the pin order.  If you are using a         //// 
.................... ////  baseline PIC (PCB), then LCD_OUTPUT_MAP and LCD_INPUT_MAP also must  //// 
.................... ////  be defined.                                                          //// 
.................... ////                                                                       //// 
.................... ////  Example of port access:                                              //// 
.................... ////     #define LCD_DATA_PORT getenv("SFR:PORTD")                         //// 
.................... ////                                                                       //// 
.................... ////  To use pin access, the following pins must be defined:               //// 
.................... ////     LCD_ENABLE_PIN                                                    //// 
.................... ////     LCD_RS_PIN                                                        //// 
.................... ////     LCD_RW_PIN                                                        //// 
.................... ////     LCD_DATA4                                                         //// 
.................... ////     LCD_DATA5                                                         //// 
.................... ////     LCD_DATA6                                                         //// 
.................... ////     LCD_DATA7                                                         //// 
.................... ////                                                                       //// 
.................... ////  Example of pin access:                                               //// 
.................... ////     #define LCD_ENABLE_PIN  PIN_E0                                    //// 
.................... ////     #define LCD_RS_PIN      PIN_E1                                    //// 
.................... ////     #define LCD_RW_PIN      PIN_E2                                    //// 
.................... ////     #define LCD_DATA4       PIN_D4                                    //// 
.................... ////     #define LCD_DATA5       PIN_D5                                    //// 
.................... ////     #define LCD_DATA6       PIN_D6                                    //// 
.................... ////     #define LCD_DATA7       PIN_D7                                    //// 
.................... ////                                                                       //// 
.................... /////////////////////////////////////////////////////////////////////////////// 
.................... ////        (C) Copyright 1996,2010 Custom Computer Services           //// 
.................... //// This source code may only be used by licensed users of the CCS C  //// 
.................... //// compiler.  This source code may only be distributed to other      //// 
.................... //// licensed users of the CCS C compiler.  No other use, reproduction //// 
.................... //// or distribution is permitted without written permission.          //// 
.................... //// Derivative programs created using this software in object code    //// 
.................... //// form are not restricted in any way.                               //// 
.................... /////////////////////////////////////////////////////////////////////////// 
....................  
.................... #ifndef __LCD_C__ 
.................... #define __LCD_C__ 
....................  
.................... // define the pinout. 
.................... // only required if port access is being used. 
.................... typedef struct   
.................... {                            // This structure is overlayed 
....................    int1 enable;           // on to an I/O port to gain 
....................    int1 rs;               // access to the LCD pins. 
....................    int1 rw;               // The bits are allocated from 
....................    int1 unused;           // low order up.  ENABLE will 
....................    unsigned int     data : 4;         // be LSB pin of that port. 
....................   #if defined(__PCD__)       // The port used will be LCD_DATA_PORT. 
....................    unsigned int    reserved: 8; 
....................   #endif 
.................... } LCD_PIN_MAP; 
....................  
.................... // this is to improve compatability with previous LCD drivers that accepted 
.................... // a define labeled 'use_portb_lcd' that configured the LCD onto port B. 
.................... #if ((defined(use_portb_lcd)) && (use_portb_lcd==TRUE)) 
....................  #define LCD_DATA_PORT getenv("SFR:PORTB") 
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    // these definitions only need to be modified for baseline PICs. 
....................    // all other PICs use LCD_PIN_MAP or individual LCD_xxx pin definitions. 
.................... /*                                    EN, RS,   RW,   UNUSED,  DATA  */ 
....................  const LCD_PIN_MAP LCD_OUTPUT_MAP =  {0,  0,    0,    0,       0}; 
....................  const LCD_PIN_MAP LCD_INPUT_MAP =   {0,  0,    0,    0,       0xF}; 
.................... #endif 
....................  
.................... ////////////////////// END CONFIGURATION /////////////////////////////////// 
....................  
.................... #ifndef LCD_ENABLE_PIN 
....................    #define lcd_output_enable(x) lcdlat.enable=x 
....................    #define lcd_enable_tris()   lcdtris.enable=0 
.................... #else 
....................    #define lcd_output_enable(x) output_bit(LCD_ENABLE_PIN, x) 
....................    #define lcd_enable_tris()  output_drive(LCD_ENABLE_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RS_PIN 
....................    #define lcd_output_rs(x) lcdlat.rs=x 
....................    #define lcd_rs_tris()   lcdtris.rs=0 
.................... #else 
....................    #define lcd_output_rs(x) output_bit(LCD_RS_PIN, x) 
....................    #define lcd_rs_tris()  output_drive(LCD_RS_PIN) 
.................... #endif 
....................  
.................... #ifndef LCD_RW_PIN 
....................    #define lcd_output_rw(x) lcdlat.rw=x 
....................    #define lcd_rw_tris()   lcdtris.rw=0 
.................... #else 
....................    #define lcd_output_rw(x) output_bit(LCD_RW_PIN, x) 
....................    #define lcd_rw_tris()  output_drive(LCD_RW_PIN) 
.................... #endif 
....................  
.................... // original version of this library incorrectly labeled LCD_DATA0 as LCD_DATA4, 
.................... // LCD_DATA1 as LCD_DATA5, and so on.  this block of code makes the driver 
.................... // compatible with any code written for the original library 
.................... #if (defined(LCD_DATA0) && defined(LCD_DATA1) && defined(LCD_DATA2) && defined(LCD_DATA3) && !defined(LCD_DATA4) && !defined(LCD_DATA5) && !defined(LCD_DATA6) && !defined(LCD_DATA7)) 
....................    #define  LCD_DATA4    LCD_DATA0 
....................    #define  LCD_DATA5    LCD_DATA1 
....................    #define  LCD_DATA6    LCD_DATA2 
....................    #define  LCD_DATA7    LCD_DATA3 
.................... #endif 
....................  
.................... #ifndef LCD_DATA4 
.................... #ifndef LCD_DATA_PORT 
....................    #if defined(__PCB__) 
....................       #define LCD_DATA_PORT      0x06     //portb 
....................       #define set_tris_lcd(x)   set_tris_b(x) 
....................    #else 
....................      #if defined(PIN_D0) 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTD")     //portd 
....................      #else 
....................       #define LCD_DATA_PORT      getenv("SFR:PORTB")     //portb 
....................      #endif 
....................    #endif    
.................... #endif 
....................  
.................... #if defined(__PCB__) 
....................    LCD_PIN_MAP lcd, lcdlat; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
.................... #elif defined(__PCM__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT 
....................    #byte lcdtris = LCD_DATA_PORT+0x80 
.................... #elif defined(__PCH__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #byte lcd = LCD_DATA_PORT 
....................    #byte lcdlat = LCD_DATA_PORT+9 
....................    #byte lcdtris = LCD_DATA_PORT+0x12 
.................... #elif defined(__PCD__) 
....................    LCD_PIN_MAP lcd, lcdlat, lcdtris; 
....................    #word lcd = LCD_DATA_PORT 
....................    #word lcdlat = LCD_DATA_PORT+2 
....................    #word lcdtris = LCD_DATA_PORT-0x02 
.................... #endif 
.................... #endif   //LCD_DATA4 not defined 
....................  
.................... #ifndef LCD_TYPE 
....................    #define LCD_TYPE 2           // 0=5x7, 1=5x10, 2=2 lines 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_TWO 
....................    #define LCD_LINE_TWO 0x40    // LCD RAM address for the second line 
.................... #endif 
....................  
.................... #ifndef LCD_LINE_LENGTH 
....................    #define LCD_LINE_LENGTH 20 
.................... #endif 
....................  
.................... unsigned int8 lcd_read_nibble(void); 
....................  
.................... unsigned int8 lcd_read_byte(void) 
.................... { 
....................    unsigned int8 low,high; 
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_INPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_float(LCD_DATA4); 
....................    output_float(LCD_DATA5); 
....................    output_float(LCD_DATA6); 
....................    output_float(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0xF; 
*
00BA:  MOVLW  0F
00BC:  ANDWF  F93,W
00BE:  IORLW  F0
00C0:  MOVWF  F93
....................   #endif 
....................  #endif 
....................          
....................    lcd_output_rw(1); 
00C2:  BSF    F8A.2
....................    delay_cycles(1); 
00C4:  NOP   
....................    lcd_output_enable(1); 
00C6:  BSF    F8A.0
....................    delay_cycles(1); 
00C8:  NOP   
....................    high = lcd_read_nibble(); 
00CA:  RCALL  00AE
00CC:  MOVFF  01,4B
....................        
....................    lcd_output_enable(0); 
00D0:  BCF    F8A.0
....................    delay_cycles(1); 
00D2:  NOP   
....................    lcd_output_enable(1); 
00D4:  BSF    F8A.0
....................    delay_us(1); 
00D6:  NOP   
....................    low = lcd_read_nibble(); 
00D8:  RCALL  00AE
00DA:  MOVFF  01,4A
....................        
....................    lcd_output_enable(0); 
00DE:  BCF    F8A.0
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
00E0:  MOVLW  0F
00E2:  ANDWF  F93,W
00E4:  MOVWF  F93
....................   #endif 
....................  #endif 
....................  
....................    return( (high<<4) | low); 
00E6:  SWAPF  4B,W
00E8:  MOVWF  00
00EA:  MOVLW  F0
00EC:  ANDWF  00,F
00EE:  MOVF   00,W
00F0:  IORWF  4A,W
00F2:  MOVWF  01
00F4:  RETURN 0
.................... } 
....................  
.................... unsigned int8 lcd_read_nibble(void) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    unsigned int8 n = 0x00; 
....................  
....................    /* Read the data port */ 
....................    n |= input(LCD_DATA4); 
....................    n |= input(LCD_DATA5) << 1; 
....................    n |= input(LCD_DATA6) << 2; 
....................    n |= input(LCD_DATA7) << 3; 
....................     
....................    return(n); 
....................   #else 
....................    return(lcd.data); 
*
00AE:  MOVF   F81,W
00B0:  MOVWF  00
00B2:  SWAPF  00,W
00B4:  ANDLW  0F
00B6:  MOVWF  01
....................   #endif 
00B8:  RETURN 0
.................... } 
....................  
.................... void lcd_send_nibble(unsigned int8 n) 
.................... { 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    /* Write to the data port */ 
....................    output_bit(LCD_DATA4, bit_test(n, 0)); 
....................    output_bit(LCD_DATA5, bit_test(n, 1)); 
....................    output_bit(LCD_DATA6, bit_test(n, 2)); 
....................    output_bit(LCD_DATA7, bit_test(n, 3)); 
....................   #else       
....................    lcdlat.data = n; 
*
00F6:  SWAPF  4B,W
00F8:  ANDLW  F0
00FA:  MOVWF  00
00FC:  MOVLW  0F
00FE:  ANDWF  F8A,W
0100:  IORWF  00,W
0102:  MOVWF  F8A
....................   #endif 
....................        
....................    delay_cycles(1); 
0104:  NOP   
....................    lcd_output_enable(1); 
0106:  BSF    F8A.0
....................    delay_us(2); 
0108:  BRA    010A
....................    lcd_output_enable(0); 
010A:  BCF    F8A.0
010C:  RETURN 0
.................... } 
....................  
.................... void lcd_send_byte(unsigned int8 address, unsigned int8 n) 
.................... { 
....................   #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................   #else 
....................    lcd_enable_tris(); 
010E:  BCF    F93.0
....................    lcd_rs_tris(); 
0110:  BCF    F93.1
....................    lcd_rw_tris(); 
0112:  BCF    F93.2
....................   #endif 
....................  
....................    lcd_output_rs(0); 
0114:  BCF    F8A.1
....................    while ( bit_test(lcd_read_byte(),7) ) ; 
0116:  RCALL  00BA
0118:  MOVFF  01,4A
011C:  BTFSC  01.7
011E:  BRA    0116
....................    lcd_output_rs(address); 
0120:  BCF    F8A.1
0122:  BTFSC  48.0
0124:  BSF    F8A.1
....................    delay_cycles(1); 
0126:  NOP   
....................    lcd_output_rw(0); 
0128:  BCF    F8A.2
....................    delay_cycles(1); 
012A:  NOP   
....................    lcd_output_enable(0); 
012C:  BCF    F8A.0
....................    lcd_send_nibble(n >> 4); 
012E:  SWAPF  49,W
0130:  MOVWF  4A
0132:  MOVLW  0F
0134:  ANDWF  4A,F
0136:  MOVFF  4A,4B
013A:  RCALL  00F6
....................    lcd_send_nibble(n & 0xf); 
013C:  MOVF   49,W
013E:  ANDLW  0F
0140:  MOVWF  4A
0142:  MOVWF  4B
0144:  RCALL  00F6
0146:  RETURN 0
.................... } 
....................  
.................... #if defined(LCD_EXTENDED_NEWLINE) 
.................... unsigned int8 g_LcdX, g_LcdY; 
.................... #endif 
....................  
.................... void lcd_init(void)  
.................... { 
....................    unsigned int8 i; 
....................    unsigned int8 LCD_INIT_STRING[4] = {0x20 | (LCD_TYPE << 2), 0xc, 1, 6}; 
*
02B2:  MOVLW  28
02B4:  MOVWF  36
02B6:  MOVLW  0C
02B8:  MOVWF  37
02BA:  MOVLW  01
02BC:  MOVWF  38
02BE:  MOVLW  06
02C0:  MOVWF  39
....................                              // These bytes need to be sent to the LCD 
....................                              // to start it up. 
....................     
....................  
....................    lcd_output_enable(0); 
02C2:  BCF    F8A.0
....................    lcd_output_rs(0); 
02C4:  BCF    F8A.1
....................    lcd_output_rw(0); 
02C6:  BCF    F8A.2
....................  
....................  #if defined(__PCB__) 
....................    set_tris_lcd(LCD_OUTPUT_MAP); 
....................  #else 
....................   #if (defined(LCD_DATA4) && defined(LCD_DATA5) && defined(LCD_DATA6) && defined(LCD_DATA7)) 
....................    output_drive(LCD_DATA4); 
....................    output_drive(LCD_DATA5); 
....................    output_drive(LCD_DATA6); 
....................    output_drive(LCD_DATA7); 
....................   #else 
....................    lcdtris.data = 0x0; 
02C8:  MOVLW  0F
02CA:  ANDWF  F93,W
02CC:  MOVWF  F93
....................   #endif 
....................    lcd_enable_tris(); 
02CE:  BCF    F93.0
....................    lcd_rs_tris(); 
02D0:  BCF    F93.1
....................    lcd_rw_tris(); 
02D2:  BCF    F93.2
02D4:  CLRF   19
02D6:  BTFSC  FF2.7
02D8:  BSF    19.7
02DA:  BCF    FF2.7
....................  #endif 
....................      
....................    delay_ms(15); 
02DC:  MOVLW  0F
02DE:  MOVWF  44
02E0:  RCALL  016A
02E2:  BTFSC  19.7
02E4:  BSF    FF2.7
....................    for(i=1;i<=3;++i) 
02E6:  MOVLW  01
02E8:  MOVWF  35
02EA:  MOVF   35,W
02EC:  SUBLW  03
02EE:  BNC   0318
02F0:  CLRF   19
02F2:  BTFSC  FF2.7
02F4:  BSF    19.7
02F6:  BCF    FF2.7
....................    { 
....................        lcd_send_nibble(3); 
02F8:  MOVLW  03
02FA:  MOVWF  4B
02FC:  RCALL  00F6
02FE:  BTFSC  19.7
0300:  BSF    FF2.7
0302:  CLRF   19
0304:  BTFSC  FF2.7
0306:  BSF    19.7
0308:  BCF    FF2.7
....................        delay_ms(5); 
030A:  MOVLW  05
030C:  MOVWF  44
030E:  RCALL  016A
0310:  BTFSC  19.7
0312:  BSF    FF2.7
0314:  INCF   35,F
0316:  BRA    02EA
0318:  CLRF   19
031A:  BTFSC  FF2.7
031C:  BSF    19.7
031E:  BCF    FF2.7
....................    } 
....................     
....................    lcd_send_nibble(2); 
0320:  MOVLW  02
0322:  MOVWF  4B
0324:  RCALL  00F6
0326:  BTFSC  19.7
0328:  BSF    FF2.7
032A:  CLRF   19
032C:  BTFSC  FF2.7
032E:  BSF    19.7
0330:  BCF    FF2.7
....................    delay_ms(5); 
0332:  MOVLW  05
0334:  MOVWF  44
0336:  RCALL  016A
0338:  BTFSC  19.7
033A:  BSF    FF2.7
....................    for(i=0;i<=3;++i) 
033C:  CLRF   35
033E:  MOVF   35,W
0340:  SUBLW  03
0342:  BNC   036A
....................       lcd_send_byte(0,LCD_INIT_STRING[i]); 
0344:  CLRF   03
0346:  MOVF   35,W
0348:  ADDLW  36
034A:  MOVWF  FE9
034C:  MOVLW  00
034E:  ADDWFC 03,W
0350:  MOVWF  FEA
0352:  MOVFF  FEF,49
0356:  CLRF   19
0358:  BTFSC  FF2.7
035A:  BSF    19.7
035C:  BCF    FF2.7
035E:  CLRF   48
0360:  RCALL  010E
0362:  BTFSC  19.7
0364:  BSF    FF2.7
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0366:  INCF   35,F
0368:  BRA    033E
036A:  GOTO   04F0 (RETURN)
....................    g_LcdX = 0; 
....................    g_LcdY = 0; 
....................   #endif 
.................... } 
....................  
.................... void lcd_gotoxy(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    unsigned int8 address; 
....................     
....................    if(y!=1) 
*
0148:  DECFSZ 45,W
014A:  BRA    014E
014C:  BRA    0154
....................       address=LCD_LINE_TWO; 
014E:  MOVLW  40
0150:  MOVWF  46
0152:  BRA    0156
....................    else 
....................       address=0; 
0154:  CLRF   46
....................       
....................    address+=x-1; 
0156:  MOVLW  01
0158:  SUBWF  44,W
015A:  ADDWF  46,F
....................    lcd_send_byte(0,0x80|address); 
015C:  MOVF   46,W
015E:  IORLW  80
0160:  MOVWF  47
0162:  CLRF   48
0164:  MOVWF  49
0166:  RCALL  010E
....................  
....................   #if defined(LCD_EXTENDED_NEWLINE) 
0168:  RETURN 0
....................    g_LcdX = x - 1; 
....................    g_LcdY = y - 1; 
....................   #endif 
.................... } 
....................  
.................... void lcd_putc(char c) 
.................... { 
....................    switch (c) 
*
0192:  MOVF   43,W
0194:  XORLW  07
0196:  BZ    01A6
0198:  XORLW  0B
019A:  BZ    01B0
019C:  XORLW  06
019E:  BZ    01C0
01A0:  XORLW  02
01A2:  BZ    01CC
01A4:  BRA    01D6
....................    { 
....................       case '\a'   :  lcd_gotoxy(1,1);     break; 
01A6:  MOVLW  01
01A8:  MOVWF  44
01AA:  MOVWF  45
01AC:  RCALL  0148
01AE:  BRA    01E0
....................  
....................       case '\f'   :  lcd_send_byte(0,1); 
01B0:  CLRF   48
01B2:  MOVLW  01
01B4:  MOVWF  49
01B6:  RCALL  010E
....................                      delay_ms(2); 
01B8:  MOVLW  02
01BA:  MOVWF  44
01BC:  RCALL  016A
....................                     #if defined(LCD_EXTENDED_NEWLINE) 
....................                      g_LcdX = 0; 
....................                      g_LcdY = 0; 
....................                     #endif 
....................                      break; 
01BE:  BRA    01E0
....................  
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       case '\r'   :  lcd_gotoxy(1, g_LcdY+1);   break; 
....................       case '\n'   : 
....................          while (g_LcdX++ < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, ' '); 
....................          } 
....................          lcd_gotoxy(1, g_LcdY+2); 
....................          break; 
....................      #else 
....................       case '\n'   : lcd_gotoxy(1,2);        break; 
01C0:  MOVLW  01
01C2:  MOVWF  44
01C4:  MOVLW  02
01C6:  MOVWF  45
01C8:  RCALL  0148
01CA:  BRA    01E0
....................      #endif 
....................       
....................       case '\b'   : lcd_send_byte(0,0x10);  break; 
01CC:  CLRF   48
01CE:  MOVLW  10
01D0:  MOVWF  49
01D2:  RCALL  010E
01D4:  BRA    01E0
....................       
....................      #if defined(LCD_EXTENDED_NEWLINE) 
....................       default     :  
....................          if (g_LcdX < LCD_LINE_LENGTH) 
....................          { 
....................             lcd_send_byte(1, c); 
....................             g_LcdX++; 
....................          } 
....................          break; 
....................      #else 
....................       default     : lcd_send_byte(1,c);     break; 
01D6:  MOVLW  01
01D8:  MOVWF  48
01DA:  MOVFF  43,49
01DE:  RCALL  010E
....................      #endif 
....................    } 
01E0:  RETURN 0
.................... } 
....................   
.................... char lcd_getc(unsigned int8 x, unsigned int8 y) 
.................... { 
....................    char value; 
....................  
....................    lcd_gotoxy(x,y); 
....................    while ( bit_test(lcd_read_byte(),7) ); // wait until busy flag is low 
....................    lcd_output_rs(1); 
....................    value = lcd_read_byte(); 
....................    lcd_output_rs(0); 
....................     
....................    return(value); 
.................... } 
....................  
.................... // write a custom character to the ram 
.................... // which is 0-7 and specifies which character array we are modifying. 
.................... // ptr points to an array of 8 bytes, where each byte is the next row of 
.................... //    pixels.  only bits 0-4 are used.  the last row is the cursor row, and 
.................... //    usually you will want to leave this byte 0x00. 
.................... void lcd_set_cgram_char(unsigned int8 which, unsigned int8 *ptr) 
.................... { 
....................    unsigned int i; 
....................  
....................    which <<= 3; 
....................    which &= 0x38; 
....................  
....................    lcd_send_byte(0, 0x40 | which);  //set cgram address 
....................  
....................    for(i=0; i<8; i++) 
....................    { 
....................       lcd_send_byte(1, *ptr++); 
....................    } 
....................    
....................    #if defined(LCD_EXTENDED_NEWLINE) 
....................     lcd_gotoxy(g_LcdX+1, g_LcdY+1);  //set ddram address 
....................    #endif 
.................... } 
....................  
.................... void lcd_cursor_on(int1 on) 
.................... { 
....................    if (on) 
....................    { 
....................       lcd_send_byte(0,0x0F);           //turn LCD cursor ON 
....................    } 
....................    else 
....................    { 
....................       lcd_send_byte(0,0x0C);           //turn LCD cursor OFF 
....................    } 
.................... } 
....................  
.................... #endif 
....................  
....................  
.................... //Habilita las funciones RS232, velocidad a 9600 baudios 
.................... #use rs232(Baud=9600,xmit=PIN_C6, rcv=PIN_C7) 
*
04AA:  BTFSS  F9E.4
04AC:  BRA    04AA
04AE:  MOVWF  FAD
04B0:  RETURN 0
....................  
.................... #use fast_io (C) 
....................  
.................... char dato[10];		//Variable para almacena el dato recibido 
.................... char ok[10]="OK\r"; 
.................... char c; 
.................... int comp; 
....................  
.................... #int_rda			//Vector de interrupción al recibir por el UART 
.................... tratamiento(){	 
.................... 	gets(dato);	//Lee el dato recibido hasta el enter<CR> (13) 
*
0208:  CLRF   FEA
020A:  MOVLW  1C
020C:  MOVWF  FE9
020E:  CLRF   FED
0210:  BTFSS  F9E.5
0212:  BRA    0210
0214:  MOVFF  FAE,FEC
0218:  MOVLW  0D
021A:  SUBWF  FEF,W
021C:  BNZ   0210
021E:  CLRF   FEC
.................... 	//c = getc(); 
.................... 	lcd_gotoxy(1,2); 
0220:  MOVLW  01
0222:  MOVWF  44
0224:  MOVLW  02
0226:  MOVWF  45
0228:  RCALL  0148
.................... 	printf(lcd_putc, "%s", dato); 
022A:  CLRF   FEA
022C:  MOVLW  1C
022E:  MOVWF  FE9
0230:  BRA    01E2
.................... 	//printf(lcd_putc, "%d", c); 
0232:  BCF    F9E.5
0234:  GOTO   0060
.................... }	 
....................  
.................... void initSim800(){ 
.................... 	comp = strcmp(ok, dato); 
*
0404:  CLRF   36
0406:  MOVLW  26
0408:  MOVWF  35
040A:  CLRF   38
040C:  MOVLW  1C
040E:  MOVWF  37
0410:  RCALL  036E
0412:  MOVFF  01,31
.................... 	while(strcmp(ok, dato) != 0){ 
0416:  CLRF   36
0418:  MOVLW  26
041A:  MOVWF  35
041C:  CLRF   38
041E:  MOVLW  1C
0420:  MOVWF  37
0422:  RCALL  036E
0424:  MOVF   01,F
0426:  BZ    0470
.................... 		printf("AT\r"); 
0428:  MOVLW  38
042A:  MOVWF  FF6
042C:  MOVLW  02
042E:  MOVWF  FF7
0430:  RCALL  03E2
0432:  CLRF   19
0434:  BTFSC  FF2.7
0436:  BSF    19.7
0438:  BCF    FF2.7
.................... 		delay_ms(100); 
043A:  MOVLW  64
043C:  MOVWF  44
043E:  RCALL  016A
0440:  BTFSC  19.7
0442:  BSF    FF2.7
.................... 		gets(dato); 
0444:  CLRF   FEA
0446:  MOVLW  1C
0448:  MOVWF  FE9
044A:  CLRF   FED
044C:  BTFSS  F9E.5
044E:  BRA    044C
0450:  MOVFF  FAE,FEC
0454:  MOVLW  0D
0456:  SUBWF  FEF,W
0458:  BNZ   044C
045A:  CLRF   FEC
.................... 		comp = strcmp(ok, dato); 
045C:  CLRF   36
045E:  MOVLW  26
0460:  MOVWF  35
0462:  CLRF   38
0464:  MOVLW  1C
0466:  MOVWF  37
0468:  RCALL  036E
046A:  MOVFF  01,31
046E:  BRA    0416
.................... 	} 
.................... 	printf("AT+IPR\r"); 
0470:  MOVLW  3C
0472:  MOVWF  FF6
0474:  MOVLW  02
0476:  MOVWF  FF7
0478:  RCALL  03E2
047A:  GOTO   04F2 (RETURN)
.................... } 
....................  
.................... void main(){ 
*
04B2:  CLRF   FF8
04B4:  BCF    FD0.7
04B6:  BSF    07.7
04B8:  BCF    FB8.3
04BA:  MOVLW  19
04BC:  MOVWF  FAF
04BE:  MOVLW  A6
04C0:  MOVWF  FAC
04C2:  MOVLW  90
04C4:  MOVWF  FAB
04C6:  CLRF   33
04C8:  CLRF   32
04CA:  MOVF   FC1,W
04CC:  ANDLW  C0
04CE:  IORLW  0F
04D0:  MOVWF  FC1
04D2:  MOVLW  07
04D4:  MOVWF  FB4
04D6:  CLRF   1A
04D8:  CLRF   1B
04DA:  MOVLW  4F
04DC:  MOVWF  26
04DE:  MOVLW  4B
04E0:  MOVWF  27
04E2:  MOVLW  0D
04E4:  MOVWF  28
04E6:  CLRF   29
04E8:  CLRF   34
.................... 	int cont=0; 
.................... 	set_tris_c(0b10111111);	//RC7/Rx entrada, RC6/Tx salida	 
04EA:  MOVLW  BF
04EC:  MOVWF  F94
.................... 	//setup_uart(uart_autodetect);	//Activa ciclo de auto detección de baudios 
.................... 	lcd_init(); 
04EE:  BRA    02B2
.................... 	initSim800(); 
04F0:  BRA    0404
.................... 	enable_interrupts(INT_RDA);		//Activa interrupción en la recepción 
04F2:  BSF    F9D.5
.................... 	enable_interrupts(global);		//Habilita interrupciones 
04F4:  MOVLW  C0
04F6:  IORWF  FF2,F
04F8:  CLRF   19
04FA:  BTFSC  FF2.7
04FC:  BSF    19.7
04FE:  BCF    FF2.7
.................... 	 
.................... 	lcd_gotoxy(1,1); 
0500:  MOVLW  01
0502:  MOVWF  44
0504:  MOVWF  45
0506:  RCALL  0148
0508:  BTFSC  19.7
050A:  BSF    FF2.7
.................... 	printf(lcd_putc, "AT+CMGS=?"); 
050C:  MOVLW  44
050E:  MOVWF  FF6
0510:  MOVLW  02
0512:  MOVWF  FF7
0514:  RCALL  047E
.................... 	printf("AT+CMGS=?\r"); //Tiene que responder OK 
0516:  MOVLW  4E
0518:  MOVWF  FF6
051A:  MOVLW  02
051C:  MOVWF  FF7
051E:  RCALL  03E2
.................... 	delay_ms(1000); 
0520:  MOVLW  04
0522:  MOVWF  35
0524:  CLRF   19
0526:  BTFSC  FF2.7
0528:  BSF    19.7
052A:  BCF    FF2.7
052C:  MOVLW  FA
052E:  MOVWF  44
0530:  RCALL  016A
0532:  BTFSC  19.7
0534:  BSF    FF2.7
0536:  DECFSZ 35,F
0538:  BRA    0524
053A:  CLRF   19
053C:  BTFSC  FF2.7
053E:  BSF    19.7
0540:  BCF    FF2.7
....................  
.................... 	lcd_gotoxy(1,1); 
0542:  MOVLW  01
0544:  MOVWF  44
0546:  MOVWF  45
0548:  RCALL  0148
054A:  BTFSC  19.7
054C:  BSF    FF2.7
.................... 	printf(lcd_putc, "AT+CMGF=1"); 
054E:  MOVLW  5A
0550:  MOVWF  FF6
0552:  MOVLW  02
0554:  MOVWF  FF7
0556:  RCALL  047E
.................... 	printf("AT+CMGF=1\r"); //Modo texto 
0558:  MOVLW  64
055A:  MOVWF  FF6
055C:  MOVLW  02
055E:  MOVWF  FF7
0560:  RCALL  03E2
.................... 	delay_ms(1000); 
0562:  MOVLW  04
0564:  MOVWF  35
0566:  CLRF   19
0568:  BTFSC  FF2.7
056A:  BSF    19.7
056C:  BCF    FF2.7
056E:  MOVLW  FA
0570:  MOVWF  44
0572:  RCALL  016A
0574:  BTFSC  19.7
0576:  BSF    FF2.7
0578:  DECFSZ 35,F
057A:  BRA    0566
057C:  CLRF   19
057E:  BTFSC  FF2.7
0580:  BSF    19.7
0582:  BCF    FF2.7
....................  
.................... 	lcd_gotoxy(1,1); 
0584:  MOVLW  01
0586:  MOVWF  44
0588:  MOVWF  45
058A:  RCALL  0148
058C:  BTFSC  19.7
058E:  BSF    FF2.7
.................... 	printf(lcd_putc, "AT+CMGS=\"+593959984110\""); 
0590:  MOVLW  70
0592:  MOVWF  FF6
0594:  MOVLW  02
0596:  MOVWF  FF7
0598:  RCALL  047E
.................... 	printf("AT+CMGS=\"+593959984110\"\r"); //Numero de telefono 
059A:  MOVLW  88
059C:  MOVWF  FF6
059E:  MOVLW  02
05A0:  MOVWF  FF7
05A2:  RCALL  03E2
.................... 	delay_ms(1000); 
05A4:  MOVLW  04
05A6:  MOVWF  35
05A8:  CLRF   19
05AA:  BTFSC  FF2.7
05AC:  BSF    19.7
05AE:  BCF    FF2.7
05B0:  MOVLW  FA
05B2:  MOVWF  44
05B4:  RCALL  016A
05B6:  BTFSC  19.7
05B8:  BSF    FF2.7
05BA:  DECFSZ 35,F
05BC:  BRA    05A8
05BE:  CLRF   19
05C0:  BTFSC  FF2.7
05C2:  BSF    19.7
05C4:  BCF    FF2.7
....................  
.................... 	lcd_gotoxy(1,1); 
05C6:  MOVLW  01
05C8:  MOVWF  44
05CA:  MOVWF  45
05CC:  RCALL  0148
05CE:  BTFSC  19.7
05D0:  BSF    FF2.7
.................... 	printf(lcd_putc, "Prueba"); 
05D2:  MOVLW  A2
05D4:  MOVWF  FF6
05D6:  MOVLW  02
05D8:  MOVWF  FF7
05DA:  RCALL  047E
.................... 	printf("Prueba"); //Mensaje 
05DC:  MOVLW  AA
05DE:  MOVWF  FF6
05E0:  MOVLW  02
05E2:  MOVWF  FF7
05E4:  RCALL  03E2
.................... 	putc(26); // CTRL+Z 
05E6:  MOVLW  1A
05E8:  RCALL  04AA
.................... 	putc('\r'); 
05EA:  MOVLW  0D
05EC:  RCALL  04AA
.................... 	delay_ms(1000); 
05EE:  MOVLW  04
05F0:  MOVWF  35
05F2:  CLRF   19
05F4:  BTFSC  FF2.7
05F6:  BSF    19.7
05F8:  BCF    FF2.7
05FA:  MOVLW  FA
05FC:  MOVWF  44
05FE:  RCALL  016A
0600:  BTFSC  19.7
0602:  BSF    FF2.7
0604:  DECFSZ 35,F
0606:  BRA    05F2
....................  
.................... 	while(1) 
.................... 	{	 
0608:  BRA    0608
.................... 		 
.................... 	} 
.................... } 
060A:  SLEEP 

Configuration Fuses:
   Word  1: C427   PLL12 CPUDIV1 USBDIV EC_IO FCMEN IESO
   Word  2: 1E38   PUT NOBROWNOUT BORV21 VREGEN NOWDT WDT32768
   Word  3: 8500   CCP2C1 NOPBADEN LPT1OSC MCLR
   Word  4: 0081   STVREN NOLVP NOXINST NODEBUG
   Word  5: C00F   NOPROTECT NOCPB NOCPD
   Word  6: E00F   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 400F   NOEBTR NOEBTRB
